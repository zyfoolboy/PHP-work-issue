## 学习计划

目前 PHP 基础比较薄弱，需要加强巩固 PHP 基础，每天晚上抽大概一个小时的时间用来持续学习。
重点：一周内，要全面系统里掌握语法.看代码先消化现在的框架，再看开源的。

近期计划：

1.PHP 基本语法巩固

	用 1 - 2 个小时看 PHP 官方手册基本语法相关内容。
	
2.PHP 数组相关函数学习

	用 2 - 4 个小时巩固 PHP 数组相关函数运用，PHP 手册的数组相关函数使用的例子自己动手写一遍。
	
3.面向对象知识学习

	用 1 - 2 个小时看 PHP 手册类与对象章节，相关案例自己动手实践一遍，空余时间多的话要找一些相关书籍，文章看一下。

4.mtphp 框架源码阅读

	框架源码用 1 周左右的业余时间过一遍，了解框架的基本原理，做到可以熟练排查并解决项目中出现的问题。
	
5.学习其他同事的项目代码

	多看一些其他同事的项目代码，学习团队的代码规范，编码风格，做到可以独立负责项目的一个模块。
	
6.熟悉 Linux 操作

	平时多实践常用的 Linux 命令，要做到可以在服务器上熟练的调试项目，快速解决 bug。
	

## 记录
### 20180511 22:10 - 23:10

语言参考 
	
**基本语法**

	PHP 标记
	从 HTML 中分离
	指令分隔符
	注释


**类型**
	
	PHP 支持 9 种原始数据类型
	
	gettype() 函数获得变量类型
	is_tpye 函数检验类型 edg：is_int(),is_string()
	settpye() 强制类型转换
	
	如果给定的一个数超出了 integer 的范围，将会被解释为 float。同样如果执行的运算结果超出	了 integer 范围，也会返回 float。
	
	浮点数的精度有限，不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用任意精度数学函数或者 gmp 函数。
	
	字符串在单引号字符串中的变量和特殊字符的转义序列将不会被替换。
	
	数组中 key 可以是 integer 或者 string。	◦	包含有合法整型值的字符串会被转换为整型。
	◦	浮点数，布尔值也会被转换为整型。
	◦	Null 会被转换为空字符串，即键名 null 实际会被储存为 ""。
	◦	数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。

### 20180513 21:50 - 23:10

	PHP是将函数以string形式传递的。
	一个已实例化的 object 的方法被作为 array 传递，下标 0 包含该 object，下标 1 包含方法名。
	静态类方法也可不经实例化该类的对象而传递，只要在下标 0 中包含类名而不是对象。

**变量**

	$this 是一个特殊的变量，它不能被赋值。
	静态变量如果在声明中用表达式的结果对其赋值会导致解析错误。
	静态声明是在编译时解析的。
	要将可变变量用于数组，必须解决一个模棱两可的问题。这就是当写下 $$a[1] 时，解析器需要知道是想要 $a[1]作为一个变量呢，还是想要 $$a 作为一个变量并取出该变量中索引为 [1] 的值。解决此问题的语法是，对第一种情况用 ${$a[1]}，对第二种情况用 ${$a}[1]。

[test1.php](https://github.com/zyfoolboy/PHP-work-issues/blob/master/page/201805/test1.php)

### 20180514 22:10 - 23:30

**表达式**

	在 PHP 中，几乎所写的任何东西都是一个表达式。简单但却最精确的定义一个表达式的方式就是“任何有值的东西”。
	函数也是表达式，表达式的值即为它们的返回值。
**运算符**
	
	PHP 支持引用赋值，使用“$var = &$othervar;”语法。引用赋值意味着两个变量指向了同一个数据，没有拷贝任何东西。
	$a <=> $b 太空船运算符（组合比较符）当$a小于、等于、大于$b时 分别返回一个小于、等于、大于0的integer 值。 PHP7开始提供.
	$a ?? $b ?? $c NULL 合并操作符 从左往右第一个存在且不为 NULL 的操作数。如果都没有定义且不为 NULL，则返回 NULL。PHP7开始提供。（和 ?: 有一点不一样 $a ?? $b 是判断 $a 是否有值， $a ?: $b 是判断 $a 是否为真）
	由于浮点数 float 的内部表达方式，不应比较两个浮点数float是否相等。
	PHP 支持一个错误控制运算符：@。
	PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符“`”的效果与函数shell_exec() 相同。
	数组 + 运算符把右边的数组元素附加到左边的数组后面，两个数组中都有的键名，则只用左边数组中的，右边的被忽略。
	检查一个对象是否不是某个类的实例，可以使用逻辑运算符 not。
	instanceof也可用于确定一个变量是不是实现了某个接口的对象的实例:
	虽然 instanceof 通常直接与类名一起使用，但也可以使用对象或字符串变量

[operator.php](https://github.com/zyfoolboy/PHP-work-issues/blob/master/page/201805/operator.php) [list_function.php](https://github.com/zyfoolboy/PHP-work-issues/blob/master/page/201805/list_function.php)

### 20180515 20:10 - 23:10

**流程控制**

	一般用法是 declare(ticks=N);Zend引擎每执行1条低级语句就去执行一次 register_tick_function() 注册的函数。可以粗略的理解为每执行一句php代码（例如:$num=1;）就去执行下已经注册的tick函数。
	require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include 只产生警告（E_WARNING），脚本会继续运行。
	当一个文件被包含时，语法解析器在目标文件的开头脱离 PHP 模式并进入 HTML 模式，到文件结尾处恢复。由于此原因，目标文件中需要作为 PHP 代码执行的任何代码都必须被包括在有效的 PHP 起始和结束标记之中。
	
**函数**

	匿名函数目前是通过 Closure 类来实现的。

[declare.php](https://github.com/zyfoolboy/PHP-work-issues/blob/master/page/201805/declare.php)

[include](https://github.com/zyfoolboy/PHP-work-issues/blob/master/page/201805/include)

### 20180516 21:40 - 22:40

**类与对象**

	可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。
	常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。
	接口（interface）中也可以定义常量。

	PHP 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。

	析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 parent::__destruct()。此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。析构函数即使在使用 exit() 终止脚本运行时也会被调用。
	
	对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。如果用 var 定义，则被视为公有。
	同一个类的对象即使不是同一个实例也可以互相访问对方的私有与受保护成员。这是由于在这些对象的内部具体实现的细节都是已知的。

	声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。静态属性不可以由对象通过 -> 操作符来访问。静态属性只能被初始化为文字或常量，不能使用表达式。所以可以把静态属性初始化为整数或数组，但不能初始化为另一个变量或函数返回值，也不能指向一个对象。

	定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；

### 20180517 22:20 - 23:20

**接口**

使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。
接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。接口中定义的所有方法都必须是公有，这是接口的特性。

要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。
实现多个接口时，接口中的方法不能有重名。接口也可以继承，通过使用 extends 操作符。

**Trait**

Trait 是为 PHP 的单继承语言特性准备的代码复用机制。Trait 不能实例化。它为传统继承增加了水平特性的组合；也就是说， Class 之间不需要有继承关系。

**Final**

如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。


当使用比较运算符（==）比较两个对象变量时，比较的原则是：如果两个对象的属性和属性值 都相等，而且两个对象是同一个类的实例，那么这两个对象变量相等。

而如果使用全等运算符（===），这两个对象变量一定要指向某个类的同一个实例（即同一个对象）。

**命名空间**

命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，除了一个以外：declare关键字。另外，所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前。PHP 允许将同一个命名空间的内容分割存放在不同的文件中。

### 20180518 22:10 - 23:10

PHP 可以在同一个文件中定义多个命名空间。语法格式有两种：

```
<?php
namespace MyProject;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }

namespace AnotherProject;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
?>
```

大括号语法：

```
<?php
namespace MyProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}

namespace AnotherProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}
?>
```

PHP支持两种抽象的访问当前命名空间内部元素的方法，__NAMESPACE__ 魔术常量和namespace关键字。常量__NAMESPACE__的值是包含当前命名空间名称的字符串。

```
<?php
namespace MyProject;

echo '"', __NAMESPACE__, '"'; // 输出 "MyProject"
?>
```

关键字 namespace 可用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符。

```
<?php
namespace MyProject;

function test() {
    echo '123';
}

const CONSTANT = 222;

namespace\test(); //输出 123

$b = namespace\CONSTANT;

echo $b;//输出 222
?>
```

### 20180519  22:30 - 23:30

**PHP 7 错误处理**

PHP 7 的错误异常可以被第一个匹配的 try / catch 块所捕获。如果没有匹配的 catch 块，则调用异常处理函数（事先通过 set_exception_handler() 注册）进行处理。 如果尚未注册异常处理函数，则按照传统方式处理：被报告为一个致命错误（Fatal Error）。

Error 类并非继承自 Exception 类，所以不能用 `catch (Exception $e) { ... } `来捕获 Error。你可以用 `catch (Error $e) { ... }`，或者通过注册异常处理函数（ set_exception_handler()）来捕获 Error。

对 20180513 补充

原：
     PHP是将函数以string形式传递的。
	   一个已实例化的 object 的方法被作为 array 传递，下标 0 包含该 object，下标 1 包含方法名。
	   静态类方法也可不经实例化该类的对象而传递，只要在下标 0 中包含类名而不是对象。
	   
	   
普通的函数调用，函数名是以string传递的 `'test'()` 可以访问test() 方法;
对于实例化的 object 以数组传递，数组第一个是一个已经实例化的对象，第二个是方法命，`[$this, 'foo']()` 也可以访问;


```
<?php
class Test {
	public function foo() {
		echo "function name is foo \n";
	}	
	
	public static function tt() {
		echo "function name is tt \n";
	}
}

function ww() {
	echo "function name is ww \n";
}

$test = new Test;

[$test, 'foo']();
['Test', 'tt']();
'ww'();
?>
```

### 20180520 22:00 - 23:00

**生成器**

生成器的核心是yield关键字。它最简单的调用形式看起来像一个return申明，不同之处在于普通return会返回值并终止函数的执行，而yield会返回一个值给循环调用此生成器的代码并且只是暂停执行生成器函数。

参考：
[在PHP中使用协程实现多任务调度](http://www.laruence.com/2015/05/28/3038.html)
[PHP yield 分析](https://www.cnblogs.com/lynxcat/p/7954456.html)

