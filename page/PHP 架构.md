## 设计模式

设计模式分为三大类：创建型模式、结构型模式、行为型模式。

### 创建型模式

#### 工厂模式

1.简单工厂模式

又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

简单工厂的作用在于使对象的创建与使用分离，将对象的创建交给专门的工厂类负责，但是这样不够灵活，当新增一个类时就要修改工厂类的代码，当类比较多的时候工厂方法的代码就会很复杂。

[参考代码](https://github.com/zyfoolboy/PHP-work-issues/tree/master/page/201806/DesignPatterns/Creational/Factory)


2.工厂方法模式

此模式中，通过定义一个抽象的核心工厂类，并定义创建产品对象的接口，创建具体产品实例的工作延迟到其工厂子类去完成。
工厂方法模式是简单工厂模式的升级版，核心的工厂类不在负责所有的对象的创建，而是 把创建对象的工作交给相应的子类去做。当有新的类的时候，不必去修改原有的类，只需要新增加子类即可。

[参考代码](https://github.com/zyfoolboy/PHP-work-issues/tree/master/page/201806/DesignPatterns/Creational/FactoryMethod)

3.抽象工厂模式

为一个产品族提供了统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类。

此模式是对工厂方法模式的进一步扩展。在工厂方法模式中，一个具体的工厂负责生产一类具体的产品，即一对一的关系，但是，如果需要一个具体的工厂生产多种产品对象，那么就需要用到抽象工厂模式了。

在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。

[参考代码](https://github.com/zyfoolboy/PHP-work-issues/tree/master/page/201806/DesignPatterns/Creational/AbstractFactory)

#### 建造者模式

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。

饭店的套餐可以用建造者模式描述，一个套餐包含多种食物（主食，辅食，饮料等），属于组合品。餐厅的服务员根据套餐信息给不同的厨师传递请求，厨师分别做完之后给到服务员，服务员把这些食物打包组合成套餐给到顾客。

[参考代码](https://github.com/zyfoolboy/PHP-work-issues/tree/master/page/201806/DesignPatterns/Creational/Builder)

#### 单例模式

单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。

单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。

单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法。该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。

单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。

单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。


### 适配器模式

将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。
在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者(Adaptee)，即被适配的类。


### 桥接模式




